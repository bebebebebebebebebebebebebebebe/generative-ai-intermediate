# 第3回：知識ブロックと外部ナレッジベース

## この回で学ぶこと

- ナレッジベースの本質と仕組み
- RAG（Retrieval-Augmented Generation）の理解
- Difyでの知識ベース作成と管理
- 知識検索ノードの使い方
- 外部知識ソースの活用方法
- カスタムツールとMCPツールによる情報取得

**前提知識：** 第2回までの内容（LLMノードとプロンプト設計）を理解していることが望ましいです。

---

## 目次

1. [ナレッジベースとは](#1-ナレッジベースとは)
2. [RAGの仕組み](#2-ragの仕組み)
3. [Difyでの知識ベース作成](#3-difyでの知識ベース作成)
4. [知識検索ノードの使い方](#4-知識検索ノードの使い方)
5. [実践：RAGアプリケーションを作る](#5-実践ragアプリケーションを作る)
6. [外部ナレッジベースの活用](#6-外部ナレッジベースの活用)
7. [カスタムツールとMCPツール](#7-カスタムツールとmcpツール)

---

## 1. ナレッジベースとは

### ナレッジベースの本質

**ナレッジベース（知識ベース）** とは、LLMが推論・生成時に参照するための、**整理・保存・検索可能な外部知識の集合**です。

```
[外部知識] → [整理・保存] → [検索可能な状態] → [LLMが参照] → [正確な回答]
```

### 重要な理解：RAGは手段であって本質ではない

多くの人が「ナレッジベース = RAG」と考えがちですが、これは正確ではありません。

**ナレッジベースの本質：**
- LLMが利用できる外部知識の集合
- 信頼できる情報源
- 検索・取得可能な構造化された知識

**RAGの役割：**
- ナレッジベースから知識を**取得する手段の一つ**
- ベクトル検索を使った効率的な情報検索方法

### 外部知識を取得する様々な方法

ナレッジベースへのアクセス方法は、RAGだけではありません：

| 方法 | 説明 | 使いどころ |
|------|------|-----------|
| **RAG（ベクトル検索）** | 文章を埋め込みベクトルに変換して類似検索 | ドキュメント、FAQ、マニュアル |
| **カスタムツール** | 独自のAPIやデータベースから情報取得 | 在庫情報、顧客データ、リアルタイムデータ |
| **MCPツール** | Model Context Protocolを使った統合 | Notion、Google Drive、外部システム |
| **Webスクレイピング** | Webサイトから最新情報を取得 | ニュース、価格情報、公開データ |
| **データベースクエリ** | SQLなどで直接データベースにアクセス | 商品情報、取引履歴 |

### LLMの限界とナレッジベースの必要性

**LLMだけでは不十分な理由：**

1. **知識の鮮度**
   - LLMの学習データは過去のもの（カットオフ日あり）
   - 最新情報や最近の出来事には対応できない

2. **専門知識の不足**
   - 企業独自の情報（社内マニュアル、製品仕様）
   - 個人的な情報（日記、ノート）
   - ニッチな専門分野

3. **ハルシネーション（幻覚）**
   - 知らないことを「知っているふり」をして答える
   - もっともらしいが間違った情報を生成

**ナレッジベースを使うメリット：**

✅ **正確性の向上**
- 信頼できる情報源から回答を生成
- 根拠のある回答（ソース付き）

✅ **最新情報の活用**
- リアルタイムで更新される情報にアクセス
- ドキュメントを更新すれば即座に反映

✅ **専門性の実現**
- 企業独自の知識を活用
- カスタマイズされた回答

---

## 2. RAGの仕組み

### RAGとは

**RAG（Retrieval-Augmented Generation：検索拡張生成）** は、外部知識検索と言語生成を組み合わせた技術です。

### RAGの3つのステップ

```
ステップ1: インデキシング（事前準備）
[文書] → [分割（チャンク化）] → [埋め込み変換] → [ベクトルDB保存]

ステップ2: 検索（Retrieval）
[ユーザーの質問] → [埋め込み変換] → [類似検索] → [関連文書取得]

ステップ3: 生成（Generation）
[関連文書] + [質問] → [LLM] → [根拠のある回答]
```

### ステップ1: インデキシング（事前準備）

文書を検索可能な形に変換します。

#### 1-1. チャンク化（文書の分割）

長い文書を小さな単位（チャンク）に分割します。

**なぜ分割するのか：**
- LLMには入力できる文字数に制限がある
- 関連する部分だけを効率的に取得するため

**チャンクの例：**
```
【元の文書】（1000文字の製品マニュアル）

↓ チャンク化

【チャンク1】（200文字）
製品の概要と特徴について...

【チャンク2】（200文字）
セットアップ手順について...

【チャンク3】（200文字）
トラブルシューティングについて...
```

**チャンクサイズの設定：**

| サイズ | 目安 | 使いどころ |
|--------|------|-----------|
| **小さい（100-200トークン）** | 1-2段落 | 短い質問、キーワード検索 |
| **中程度（300-500トークン）** | 数段落 | 一般的なドキュメント |
| **大きい（800-1000トークン）** | 複数段落、長文 | 詳細な説明が必要な場合 |

#### 1-2. 埋め込み変換（Embedding）

テキストを数値ベクトルに変換します。

**埋め込みとは：**
```
テキスト「猫は可愛い動物です」
↓ 埋め込みモデル
ベクトル [0.2, -0.5, 0.8, 0.1, ...]（1536次元など）
```

**埋め込みの性質：**
- 意味が似た文章は、ベクトル空間で近い位置になる
- 「犬は可愛い」と「猫は可愛い」は近い
- 「猫は可愛い」と「数学の公式」は遠い

**主要な埋め込みモデル：**

| モデル | 提供元 | 次元数 | 特徴 |
|--------|--------|--------|------|
| **text-embedding-ada-002** | OpenAI | 1536 | 高性能、英語に強い |
| **text-embedding-3-small** | OpenAI | 1536 | コスト効率が良い |
| **text-embedding-3-large** | OpenAI | 3072 | 最高性能 |
| **embedding-001** | Google | 768 | 多言語対応 |

#### 1-3. ベクトルデータベース保存

生成されたベクトルを専用のデータベースに保存します。

**ベクトルデータベースの役割：**
- 高速な類似検索
- 大量のベクトルを効率的に管理

**主要なベクトルDB：**
- **Pinecone** - クラウド型、簡単に使える
- **Weaviate** - オープンソース、多機能
- **Qdrant** - 高速、Rust製
- **Dify内蔵DB** - Difyに組み込み済み

### ステップ2: 検索（Retrieval）

ユーザーの質問から関連する文書を取得します。

#### 2-1. 質問の埋め込み変換

```
ユーザーの質問「製品のセットアップ方法は?」
↓ 同じ埋め込みモデル
ベクトル [0.3, -0.4, 0.7, 0.2, ...]
```

#### 2-2. 類似検索

ベクトルデータベースで、質問に近いチャンクを探します。

**検索パラメータ：**

**Top K（上位K件）**
- 取得する文書の数
- 例：Top K = 3 → 最も関連度が高い3件を取得

**スコア閾値（Score Threshold）**
- 関連度の最低基準（0〜1）
- 例：0.7以上のもののみ取得

```
質問ベクトル vs データベース内のベクトル
↓ コサイン類似度計算
スコア: 0.95（チャンク2：セットアップ手順） ← 最も関連
スコア: 0.72（チャンク1：製品概要）
スコア: 0.45（チャンク3：トラブルシューティング）

→ Top K=2, 閾値=0.7 の場合
  → チャンク2とチャンク1を取得
```

### ステップ3: 生成（Generation）

取得した文書を使ってLLMが回答を生成します。

#### プロンプトの構成

```
【システムプロンプト】
あなたは親切なアシスタントです。
以下の情報を参考に、ユーザーの質問に答えてください。

【参考情報】（検索で取得した文書）
---
チャンク2（スコア: 0.95）
セットアップ手順：
1. 電源ケーブルを接続
2. 初期設定画面で言語を選択
3. Wi-Fi設定を完了
---
チャンク1（スコア: 0.72）
本製品は...
---

【ユーザーの質問】
製品のセットアップ方法は?

【回答】
```

**LLMの出力：**
```
製品のセットアップは以下の手順で行います：

1. 電源ケーブルを本体に接続してください
2. 初期設定画面が表示されたら、使用する言語を選択します
3. Wi-Fi設定を完了させてください

これでセットアップは完了です。
```

### RAGのメリットとデメリット

#### メリット

✅ **正確性の向上**
- 実際の文書に基づいた回答
- ハルシネーションの減少

✅ **ソースの提示**
- どの文書から情報を得たか明示
- 信頼性の向上

✅ **知識の更新が容易**
- 文書を追加・更新すれば即座に反映
- モデルの再学習不要

#### デメリット

❌ **初期設定のコスト**
- 文書の準備とインデキシング
- 埋め込みモデルの選定

❌ **検索精度の課題**
- 関連する文書が見つからない場合がある
- チャンクサイズの調整が必要

❌ **処理時間**
- 検索 + 生成で通常のLLMより遅い

---

## 3. Difyでの知識ベース作成

### ステップ1: 知識ベースの作成

1. Difyにログイン
2. 左メニューから「ナレッジ」をクリック
3. 「ナレッジベースを作成」ボタンをクリック
4. 以下を設定：
   - **名前**：わかりやすい名前（例：「製品マニュアル」）
   - **説明**：このナレッジベースの用途
   - **権限**：「自分のみ」または「チーム全体」

### ステップ2: ドキュメントのアップロード

Difyは様々な形式のドキュメントをサポートしています。

#### 対応ファイル形式

| カテゴリ | 形式 |
|---------|------|
| **文書** | TXT, MD, PDF, DOCX |
| **表計算** | CSV, XLSX |
| **コード** | HTML, JSON, XML |
| **その他** | Markdown, RTF |

#### アップロード方法

**方法1: ファイルアップロード**

1. 「ドキュメントを追加」をクリック
2. 「ファイルをアップロード」を選択
3. ファイルを選択またはドラッグ&ドロップ
4. アップロード完了を待つ

**方法2: テキスト入力**

1. 「ドキュメントを追加」をクリック
2. 「テキストを入力」を選択
3. ドキュメント名とテキストを入力
4. 保存

**方法3: Webサイトから取得**

1. 「ドキュメントを追加」をクリック
2. 「Webページから同期」を選択
3. URLを入力
4. 取得設定を選択（単一ページ or サイト全体）

**方法4: Notion連携**

1. 「ドキュメントを追加」をクリック
2. 「Notionから同期」を選択
3. Notionアカウントと連携
4. 取り込むページを選択

### ステップ3: チャンク化設定

アップロード後、ドキュメントをどのように分割するか設定します。

#### 自動モード（推奨）

Difyが自動的に最適な分割を行います。

**設定項目：**
- **チャンクサイズ**：500トークン（デフォルト）
- **チャンク重複**：50トークン（前後のチャンクとの重複）

**重複（Overlap）とは：**
```
【チャンク1】
...文脈が途切れないように、次の章では...

【チャンク2】（50トークン重複）
...次の章では詳しく説明します...
```
→ 文脈が繋がり、検索精度が向上

#### カスタムモード（上級者向け）

細かく設定をカスタマイズできます。

**設定項目：**

1. **前処理ルール**
   - 余分な空白を削除
   - URLとメールアドレスを削除
   - 特殊文字の処理

2. **セグメント設定**
   - **区切り文字**：`\n\n`（段落区切り）、`###`（見出し）など
   - **最大トークン数**：各チャンクの最大サイズ
   - **チャンク重複**：重複するトークン数

3. **前処理オプション**
   - **余分な改行を削除**：`はい`（推奨）
   - **URLを削除**：`はい`（ドキュメントによる）

**推奨設定例：**

```
【一般的なドキュメント】
- チャンクサイズ：500トークン
- 重複：50トークン
- 区切り文字：\n\n（段落区切り）

【FAQ形式】
- チャンクサイズ：300トークン
- 重複：30トークン
- 区切り文字：Q&A単位で区切る

【技術マニュアル】
- チャンクサイズ：800トークン
- 重複：100トークン
- 区切り文字：###（見出し区切り）
```

### ステップ4: 埋め込みモデルの選択

**デフォルト設定：**
- Difyが推奨するモデルを自動選択
- 多くの場合、これで十分

**カスタム設定：**
1. 設定アイコンをクリック
2. 「埋め込みモデル」を選択
3. モデルとプロバイダを選択

**モデル選択のポイント：**

| 用途 | 推奨モデル |
|------|-----------|
| **英語中心** | text-embedding-3-small |
| **日本語中心** | multilingual-e5-large-instruct |
| **高精度重視** | text-embedding-3-large |
| **コスト重視** | text-embedding-ada-002 |

### ステップ5: インデキシング開始

1. 設定を確認
2. 「保存してインデキシング」をクリック
3. インデキシング処理が開始されます

**進行状況の確認：**
- ドキュメントリストで進行状況を確認
- ステータス：「処理中」→「完了」
- エラーがある場合はエラーメッセージを確認

---

## 4. 知識検索ノードの使い方

### 知識検索ノードとは

**知識検索ノード（Knowledge Retrieval Node）** は、ワークフロー内でナレッジベースを検索するためのノードです。

```
[開始ノード] → [知識検索ノード] → [LLMノード] → [終了ノード]
     ↓              ↓                  ↓
  ユーザー質問   関連文書を検索    文書を参考に回答生成
```

### ノードの追加と設定

#### ステップ1: ノードの追加

1. ワークフローキャンバスで「＋」をクリック
2. 「知識検索」ノードを選択
3. ノードが追加されます

#### ステップ2: ナレッジベースの選択

1. 追加した知識検索ノードをクリック
2. 右パネルで「ナレッジベース」を選択
3. 事前に作成したナレッジベースを選択

#### ステップ3: クエリ変数の設定

検索に使用する質問文を指定します。

**通常の設定：**
```
クエリ変数：{{#start.question#}}
```
→ ユーザーの質問をそのまま検索

**LLMで質問を最適化する場合：**
```
[開始ノード] → [LLMノード：質問最適化] → [知識検索ノード]
```

LLMノード（質問最適化）のプロンプト例：
```
ユーザーの質問を、知識ベース検索に最適な形に変換してください。

【ユーザーの質問】
{{#start.user_question#}}

【最適化のポイント】
- キーワードを明確にする
- 曖昧な表現を具体化する
- 検索しやすい形式にする

【最適化された質問】
```

#### ステップ4: 検索パラメータの設定

**Top K（取得件数）**

| 設定値 | 説明 | 使いどころ |
|--------|------|-----------|
| **1-2件** | 最も関連度の高い情報のみ | 簡潔な回答、FAQ |
| **3-5件** | 標準的な設定 | 一般的なドキュメント検索 |
| **10件以上** | 幅広く情報を収集 | 複雑な質問、詳細な回答 |

**スコア閾値（Score Threshold）**

関連度の最低基準を設定します（0.0〜1.0）。

| 設定値 | 説明 |
|--------|------|
| **0.7以上** | 高い関連性のみ（厳密） |
| **0.5-0.7** | 標準的な関連性 |
| **0.5未満** | 緩い基準（広範囲に取得） |

**リランキング（Reranking）**

検索結果を再度スコアリングして精度を向上させます。

- **有効化**：より正確な結果
- **無効化**：高速だが精度は標準

**おすすめ設定：**
```
Top K: 3
スコア閾値: 0.7
リランキング: 有効
```

### ノードの出力

知識検索ノードは以下の情報を出力します：

**出力変数：**

| 変数名 | 内容 |
|--------|------|
| **result** | 検索結果のテキスト（結合済み） |
| **records** | 検索結果の配列（個別のチャンク） |

**LLMノードでの使用例：**

```
以下の情報を参考に、ユーザーの質問に答えてください。

【参考情報】
{{#知識検索ノード.result#}}

【質問】
{{#start.question#}}

【回答】
```

---

## 5. 実践：RAGアプリケーションを作る

### 演習1: 製品FAQボット

**目標：** 製品マニュアルを使った質問応答ボット

#### 手順

**1. ナレッジベースの準備**

サンプルFAQテキスト：
```
Q: 製品の保証期間はどれくらいですか？
A: 本製品は購入日から1年間の保証が付いています。

Q: 初期不良の場合はどうすればいいですか？
A: 購入後7日以内であれば、無償で交換いたします。

Q: 修理にかかる費用は？
A: 保証期間内は無料です。保証期間外は部品代と作業料が発生します。

Q: 製品のセットアップ方法は？
A: 1. 電源ケーブルを接続 2. 初期設定画面で言語を選択 3. Wi-Fi設定を完了

Q: パスワードを忘れた場合は？
A: 設定画面から「パスワードをリセット」を選択してください。
```

1. ナレッジベースを作成（名前：「製品FAQ」）
2. 上記テキストを「テキスト入力」で追加
3. チャンク設定：
   - チャンクサイズ：300トークン
   - 重複：30トークン

**2. ワークフローの構築**

```
[開始ノード]
  ↓ 入力変数：question（ユーザーの質問）
[知識検索ノード]
  ↓ ナレッジベース：製品FAQ
  ↓ Top K: 3
  ↓ スコア閾値: 0.7
[LLMノード]
  ↓
[終了ノード]
```

**3. LLMノードのプロンプト**

```
あなたは製品サポート担当者です。
FAQを参考に、ユーザーの質問に丁寧に答えてください。

【FAQ情報】
{{#知識検索ノード.result#}}

【お客様からの質問】
{{#start.question#}}

【回答のルール】
- FAQに記載されている情報を正確に伝える
- 丁寧で親切な言葉遣いを使う
- FAQに情報がない場合は「申し訳ございません、その情報はFAQに記載がございません」と伝える

【回答】
```

**4. テスト実行**

質問例：
- 「保証期間は何年ですか？」
- 「パスワードを忘れてしまいました」
- 「セットアップの手順を教えてください」

### 演習2: 社内文書検索システム

**目標：** 複数の社内文書から情報を検索

#### シナリオ

以下の3つの文書を管理：
1. 就業規則
2. 有給休暇の取り方
3. 経費精算マニュアル

#### ワークフロー構成

```
[開始ノード]
  ↓
[LLMノード1：質問の分類]（構造化出力）
  ↓
[条件分岐ノード]
  ├─ カテゴリ「就業規則」 → [知識検索ノード1：就業規則DB]
  ├─ カテゴリ「休暇」 → [知識検索ノード2：休暇DB]
  └─ カテゴリ「経費」 → [知識検索ノード3:経費DB]
  ↓
[LLMノード2：回答生成]
  ↓
[終了ノード]
```

**LLMノード1のJSON Schema：**

```json
{
  "type": "object",
  "properties": {
    "category": {
      "type": "string",
      "description": "質問のカテゴリ",
      "enum": ["就業規則", "休暇", "経費", "その他"]
    },
    "optimized_query": {
      "type": "string",
      "description": "検索に最適化された質問文"
    }
  },
  "required": ["category", "optimized_query"]
}
```

**LLMノード1のプロンプト：**

```
ユーザーの質問を分析し、適切なカテゴリに分類してください。

【質問】
{{#start.question#}}

【カテゴリ】
- 就業規則：勤務時間、服装規定、行動規範など
- 休暇：有給休暇、特別休暇、休暇申請など
- 経費：経費精算、出張費、領収書など
- その他：上記に当てはまらない質問

また、質問を検索しやすい形に最適化してください。
```

### 演習3: 引用元を表示するRAGシステム

**目標：** 回答に引用元（ソース）を明示

#### ワークフロー構成

```
[開始ノード]
  ↓
[知識検索ノード]
  ↓ records（個別チャンクの配列）を使用
[LLMノード]
  ↓
[終了ノード]
```

**LLMノードのプロンプト：**

```
以下の文書を参考に、ユーザーの質問に答えてください。
回答の最後に、参考にした文書のタイトルとスコアを記載してください。

【参考文書】
{{#知識検索ノード.result#}}

【質問】
{{#start.question#}}

【回答形式】
（回答内容）

---
参考文書：
- 文書名1（関連度: XX%）
- 文書名2（関連度: XX%）
```

**より詳細な引用を実装する場合：**

コードノード（Python）を使用して、records配列を整形：

```python
def main(records):
    sources = []
    for record in records:
        source_info = {
            "title": record.get("metadata", {}).get("title", "不明"),
            "score": round(record.get("score", 0) * 100, 1),
            "content_preview": record.get("content", "")[:100]
        }
        sources.append(source_info)

    return {
        "formatted_sources": sources
    }
```

---

## 6. 外部ナレッジベースの活用

### 外部ナレッジベースとは

**外部ナレッジベース（External Knowledge Base）** は、Difyの外部で管理されている独自のナレッジベースと連携する機能です。

### 使用するケース

| ケース | 説明 |
|--------|------|
| **既存システムとの統合** | すでに運用中の検索システムを活用 |
| **独自のベクトルDB** | Pinecone、Weaviateなど専用DBを使用 |
| **リアルタイム更新** | 常に最新データを取得したい場合 |
| **高度なフィルタリング** | メタデータによる複雑な検索条件 |

### 外部ナレッジベースAPI仕様

DifyはREST APIで外部ナレッジベースと通信します。

#### エンドポイント

```
POST <your-endpoint>/retrieval
```

#### リクエスト形式

```json
{
  "knowledge_id": "your-knowledge-id",
  "query": "ユーザーの質問",
  "retrieval_setting": {
    "top_k": 3,
    "score_threshold": 0.7
  }
}
```

#### レスポンス形式

```json
{
  "records": [
    {
      "content": "これは外部知識の文書です。",
      "score": 0.98,
      "title": "knowledge.txt",
      "metadata": {
        "path": "s3://dify/knowledge.txt",
        "description": "dify 知識文書"
      }
    },
    {
      "content": "GenAI アプリケーションの創新エンジン",
      "score": 0.66,
      "title": "introduce.txt",
      "metadata": {
        "path": "s3://dify/introduce.txt",
        "description": "dify 紹介"
      }
    }
  ]
}
```

### 実装例（Python + FastAPI）

```python
from fastapi import FastAPI, Header, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Optional

app = FastAPI()

# リクエストモデル
class RetrievalRequest(BaseModel):
    knowledge_id: str
    query: str
    retrieval_setting: Dict[str, float]

# レスポンスモデル
class Record(BaseModel):
    content: str
    score: float
    title: str
    metadata: Optional[Dict] = {}

class RetrievalResponse(BaseModel):
    records: List[Record]

@app.post("/retrieval")
async def retrieve_knowledge(
    request: RetrievalRequest,
    authorization: str = Header(None)
):
    # 認証チェック
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid authorization")

    api_key = authorization.replace("Bearer ", "")

    # APIキー検証（実際の検証ロジックを実装）
    if api_key != "your-secret-api-key":
        raise HTTPException(status_code=403, detail="Forbidden")

    # ここで実際の検索処理を実装
    # 例：独自のベクトルDBやElasticsearchを使用

    # サンプルレスポンス
    response = RetrievalResponse(
        records=[
            Record(
                content="検索結果の内容1",
                score=0.95,
                title="document1.txt",
                metadata={"category": "manual"}
            ),
            Record(
                content="検索結果の内容2",
                score=0.82,
                title="document2.txt",
                metadata={"category": "faq"}
            )
        ]
    )

    return response
```

### Difyでの設定

1. ナレッジベース作成画面で「外部ナレッジベース」を選択
2. 以下を設定：
   - **エンドポイントURL**：`https://your-api.com/retrieval`
   - **APIキー**：認証用のキー
   - **Knowledge ID**：知識ベースの識別子

---

## 7. カスタムツールとMCPツール

### ナレッジベースとツールの違い

| 項目 | ナレッジベース（RAG） | カスタムツール・MCPツール |
|------|---------------------|----------------------|
| **用途** | 静的な文書検索 | 動的な情報取得・処理 |
| **データソース** | 事前登録された文書 | リアルタイムAPI、DB、外部サービス |
| **更新頻度** | 手動更新 | 常に最新 |
| **例** | マニュアル、FAQ | 在庫照会、天気情報、Notion連携 |

### カスタムツールによる情報取得

**カスタムツール**は、独自のAPIやデータベースから情報を取得する機能です。

#### 使用例：商品在庫照会

**ツール定義（OpenAPI仕様）：**

```yaml
openapi: 3.0.0
info:
  title: 在庫照会API
  version: 1.0.0
paths:
  /inventory/check:
    post:
      summary: 商品の在庫を照会
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                product_id:
                  type: string
                  description: 商品ID
      responses:
        '200':
          description: 在庫情報
          content:
            application/json:
              schema:
                type: object
                properties:
                  product_name:
                    type: string
                  stock_quantity:
                    type: integer
                  available:
                    type: boolean
```

**ワークフローでの使用：**

```
[開始ノード]
  ↓ ユーザー入力：product_id
[カスタムツール：在庫照会]
  ↓ 在庫情報取得
[LLMノード]
  ↓ 在庫情報を自然な文章に
[終了ノード]
```

### MCPツールによる統合

**MCP（Model Context Protocol）ツール**は、外部サービスとの統合を簡単にするプロトコルです。

#### 対応サービス例

- **Notion** - ページの検索、作成、更新
- **Google Drive** - ファイル検索、取得
- **Slack** - メッセージ送信、検索
- **GitHub** - リポジトリ、Issue検索

#### Difyでの設定

1. 「設定」→「ツール」→「MCPサーバー」
2. 「サーバーを追加」をクリック
3. 接続情報を入力：
   - サーバー名
   - エンドポイントURL
   - 認証情報

#### ワークフローでの使用

```
[開始ノード]
  ↓
[MCPツール：Notion検索]
  ↓ Notionページから情報取得
[LLMノード]
  ↓ 取得した情報を整形
[終了ノード]
```

### 複合的な情報取得の例

**シナリオ：** 顧客サポートボット

```
[開始ノード：顧客からの問い合わせ]
  ↓
[LLMノード：問い合わせ分類]
  ↓
[条件分岐]
  ├─ 「製品の使い方」→ [知識検索：製品マニュアル]（RAG）
  ├─ 「注文状況」→ [カスタムツール：注文DB照会]
  ├─ 「在庫確認」→ [カスタムツール：在庫API]
  └─ 「社内情報」→ [MCPツール：Notion検索]
  ↓
[LLMノード：回答生成]
  ↓
[終了ノード]
```

**このアプローチの利点：**
- ✅ 静的な情報はRAGで効率的に検索
- ✅ リアルタイムデータはツールで取得
- ✅ 外部サービスはMCPで簡単に統合

---

## よくある質問（FAQ）

### Q1: チャンクサイズはどう決めればいいですか？

**A:** 以下の基準で判断しましょう：

**小さい（100-300トークン）：**
- FAQ形式
- 短い段落中心の文書
- キーワード検索が中心

**中程度（300-600トークン）：**
- 一般的なドキュメント
- マニュアル
- 記事

**大きい（800-1000トークン）：**
- 詳細な技術文書
- 長い説明が必要
- 文脈の連続性が重要

### Q2: Top Kとスコア閾値はどう設定すべきですか？

**A:** 以下の組み合わせを試してください：

| ケース | Top K | スコア閾値 |
|--------|-------|-----------|
| **精度重視** | 2-3 | 0.75-0.8 |
| **バランス** | 3-5 | 0.6-0.7 |
| **網羅性重視** | 5-10 | 0.5-0.6 |

### Q3: 検索結果が期待と違う場合は？

**A:** 以下を試してください：

1. **チャンクサイズの調整**
   - 小さくする：より細かく検索
   - 大きくする：より広い文脈を取得

2. **質問の最適化**
   - LLMノードで質問を言い換える
   - キーワードを明確にする

3. **埋め込みモデルの変更**
   - 日本語に強いモデルに変更
   - より高性能なモデルを試す

4. **スコア閾値を下げる**
   - より多くの候補を取得

### Q4: RAGとカスタムツールはどう使い分けるべきですか？

**A:** 以下の基準で判断しましょう：

**RAGを使う場合：**
- ✅ 文書が静的（頻繁に変わらない）
- ✅ テキスト検索が中心
- ✅ 事前に文書を準備できる

**カスタムツールを使う場合：**
- ✅ リアルタイムデータが必要
- ✅ データベースから動的に取得
- ✅ 計算や処理が必要

### Q5: 外部ナレッジベースはいつ使うべきですか？

**A:** 以下のケースで検討してください：

- 既存の検索システムがある
- 独自のベクトルDBを運用している
- 複雑なメタデータフィルタリングが必要
- Difyの制限を超える大規模データ

### Q6: 複数のナレッジベースを同時に検索できますか？

**A:** はい、可能です。以下の方法があります：

**方法1: 複数の知識検索ノードを並列実行**

```
[開始ノード]
  ├→ [知識検索ノード1：製品マニュアル]
  ├→ [知識検索ノード2：FAQ]
  └→ [知識検索ノード3：トラブルシューティング]
  ↓（すべての結果を統合）
[LLMノード]
```

**方法2: 1つのナレッジベースに統合**
- 複数の文書を同じナレッジベースに登録
- メタデータでカテゴリ分け

---

## まとめ

### この回で学んだこと

✅ **ナレッジベースの本質**
- LLMが参照する外部知識の集合
- RAGは情報取得手段の一つ
- 様々な方法で知識にアクセス可能

✅ **RAGの仕組み**
- インデキシング（チャンク化、埋め込み、保存）
- 検索（類似検索、Top K、スコア閾値）
- 生成（LLMによる回答生成）

✅ **Difyでの実装**
- ナレッジベースの作成と管理
- 知識検索ノードの使い方
- チャンク化と埋め込みモデルの設定

✅ **応用的な活用**
- 外部ナレッジベースとの連携
- カスタムツールによる動的データ取得
- MCPツールによる外部サービス統合

### 次のステップ

次回は、さらに高度な機能を学びます：

- **第4回：エージェントとツール連携**
  - AIエージェントの設計と実装
  - 複数のツールを組み合わせた複雑なワークフロー
  - 自律的なタスク実行

### 練習課題

以下のアプリケーションを自分で作ってみましょう：

1. **レシピ検索ボット**
   - 材料名から関連レシピを検索
   - 複数のレシピを比較

2. **技術文書Q&Aシステム**
   - 技術マニュアルを複数登録
   - 引用元を明示した回答

3. **社内ヘルプデスク**
   - 就業規則、経費規則などの複数文書
   - カテゴリ自動分類と適切な文書からの検索

4. **リアルタイム情報統合システム**
   - 静的FAQはRAGで検索
   - 在庫情報はカスタムツールで取得
   - 外部サービス（Notion等）の情報も活用

### 参考リンク

- [Dify公式ドキュメント - ナレッジベース](https://docs.dify.ai/guides/knowledge-base)
- [RAG（検索拡張生成）とは](https://docs.dify.ai/resources/termbase)
- [外部ナレッジベースAPI仕様](https://docs.dify.ai/guides/knowledge-base/external-knowledge-api)

---

**お疲れ様でした！** RAGとナレッジベースの理解が深まりましたか？次回はAIエージェントについて学びます。

# 第2回：LLMノードとプロンプト設計

## この回で学ぶこと

- LLMノードの基本的な使い方
- 効果的なプロンプトの書き方
- 変数を使った動的なプロンプト作成
- 実際に動くAIアプリケーションの作成

**前提知識：** プログラミングの知識は不要です。Difyの画面操作のみで学習できます。

---

## 目次

1. [LLMノードとは](#1-llmノードとは)
2. [LLMノードの追加と設定](#2-llmノードの追加と設定)
3. [プロンプトの書き方](#3-プロンプトの書き方)
4. [変数を使ったプロンプト](#4-変数を使ったプロンプト)
5. [実践：AIアシスタントを作る](#5-実践aiアシスタントを作る)
6. [構造化出力（Structured Output）](#6-構造化出力structured-output)

---

## 1. LLMノードとは

### LLMノードの役割

**LLMノード**は、ChatGPTやClaudeなどのAIモデルと会話するための部品です。

```
[ユーザーの質問] → [LLMノード] → [AIの回答]
```

### できること

- 質問に答える
- 文章を要約する
- 翻訳する
- アイデアを出す
- 文章を添削する
- など、さまざまなタスク

### ストリーミングとブロッキング

LLMノードには2つの動作モードがあります。基本的には**ストリーミング**がおすすめです。

#### ストリーミングモード（推奨）
AIが考えながら、一文字ずつリアルタイムに表示するモードです。
```
「こんに」「ちは」「、」「今日」「は」...
```
**メリット：** 待ち時間が短く感じられ、ChatGPTのようなスムーズな体験になります。

#### ブロッキングモード
AIが回答をすべて作り終えてから、一度に表示するモードです。
```
（考え中...）
↓
「こんにちは、今日はいい天気ですね」
```
**メリット：** 途中の表示が不要な場合や、他のシステムと連携する場合に使います。

---

## 2. LLMノードの追加と設定

### ステップ1: アプリケーションを作成

Difyには主に2つのアプリ作成モードがあります。今回は基本を学ぶため「ワークフロー」を使います。

1. Difyにログイン
2. 左メニューから「スタジオ」をクリック
3. 「空白のワークフローから作成」を選択
   - **注意：** 「チャットボット」を選ぶと画面構成が少し異なります
4. アプリ名を入力（例：「はじめてのLLM」）

### ステップ2: LLMノードを追加

1. キャンバス（編集画面）にある「開始」ノードの右側の「＋」をクリック
   - または、画面左上の「＋」から追加も可能です
2. ノード一覧から「LLM」を選択
3. LLMノードが追加され、線でつながります

### ステップ3: モデルを選択

LLMノードをクリックして設定画面を開きます：

**モデルの選択：**
- **Gemini**：Googleのモデル

**初心者におすすめ：** まずは「gemini-2.5-flash」から始めましょう

### ステップ4: パラメータ設定

LLMノードの右側パネルで、以下のパラメータを設定できます。

#### ストリーミング出力

**ワークフローでの設定：**
- ワークフロー型アプリケーションでは、LLMノードの出力は**デフォルトでストリーミング対応**になっています
- 特別な設定は不要で、自動的にリアルタイム表示されます

**チャットボットアプリでの設定：**
- アプリ公開時に「応答モード」を選択できます
  - **ストリーミング**：リアルタイムで文字が表示される（推奨）
  - **ブロッキング**：回答が完成してから一括表示

**注意：** ワークフロー内のLLMノード自体には、ストリーミングのオン/オフ切り替えスイッチはありません。出力の表示方法は、アプリケーションの種類や公開設定によって決まります。

#### Temperature（温度）

AIの「創造性」を調整します：

| 設定値 | 動作 | 使いどころ |
|--------|------|-----------|
| **0.0** | 毎回同じ答え | 計算問題、正確な情報 |
| **0.5** | バランス | 一般的なQ&A |
| **0.9** | 創造的な答え | 物語作成、アイデア出し |

**例：**
```
質問：「1+1は？」

Temperature 0.0 → 毎回「2です」
Temperature 0.9 → 「2です」「二つです」「2ですね」など変化
```

#### Maximum Tokens（最大トークン数）

AIが生成する文章の長さの上限です。
※「トークン」はAIが言葉を扱う単位で、日本語の場合「1トークン ≒ 0.5〜1文字」程度です。

| 設定値 | 目安 |
|--------|------|
| **512** | 短い回答（数行〜1段落） |
| **1024** | 標準的な回答（400〜800文字程度） |
| **2048** | 長文の生成（ブログ記事など） |
| **4096+** | 非常に長いレポートや詳細な解説 |

**注意：** トークン数が多いほど、生成に時間がかかり、コストも高くなる傾向があります。

#### Response Format（応答形式）

- **Text**：普通のテキスト（通常はこれ）
- **JSON**：構造化されたデータが必要な場合

---

## 3. プロンプトの書き方

### プロンプトとは

AIに対する「指示文」のことです。プロンプトの良し悪しで、AIの回答の質が大きく変わります。

### 基本的なプロンプトの構成

```
[役割] + [タスク] + [制約条件] + [出力形式]
```

### 例1: シンプルなプロンプト

**悪い例：**
```
説明して
```
→ 何を説明するのか不明確

**良い例：**
```
あなたは親切な先生です。
プロンプトエンジニアリングについて、小学生にもわかるように説明してください。
```
→ 役割とタスクが明確

### 例2: 詳細なプロンプト

```
【役割】
あなたは経験豊富なカスタマーサポート担当者です。

【タスク】
顧客からの問い合わせに対して、丁寧で分かりやすい回答を作成してください。

【制約条件】
- 敬語を使用すること
- 回答は300文字以内
- 専門用語は避けること
- 必要に応じて具体例を示すこと

【出力形式】
以下の形式で回答してください：
1. お問い合わせ内容の確認
2. 回答
3. 追加で必要な情報があれば案内
```

### プロンプトのテクニック

#### 💡 プロのテクニック：AIにプロンプトを書いてもらう

自分でゼロからプロンプトを書くのが難しい場合は、Difyの**自動生成機能**を使いましょう。

1. プロンプト入力欄の右上にある「✨（キラキラアイコン）」をクリック
2. やりたいことを一言入力（例：「美味しいカレーの作り方を教えるボット」）
3. 「生成」ボタンを押す
4. AIが考えた詳細なプロンプトが自動で入力されます

これを使えば、プロンプトエンジニアリングの知識がなくても高品質な指示が作れます。

#### テクニック1: Few-shot（例示）

AIに「お手本」を見せる方法：

```
以下の例を参考に、商品レビューを分類してください。

【例1】
レビュー：「とても良い商品でした！」
分類：ポジティブ

【例2】
レビュー：「期待外れでした」
分類：ネガティブ

【分類してください】
レビュー：「普通です」
分類：
```

#### テクニック2: ステップバイステップ

複雑なタスクを段階的に実行：

```
以下の手順で文章を要約してください：

ステップ1：文章の主題を特定する
ステップ2：重要なポイントを3つ抜き出す
ステップ3：各ポイントを1文にまとめる
ステップ4：3つの文を組み合わせて要約を作る

文章：
{ここにユーザーの文章が入る}
```

#### テクニック3: ペルソナ設定

AIに具体的な役割を与える：

```
あなたは以下の設定のキャラクターです：
- 名前：さくらAI
- 性格：明るく親しみやすい
- 口調：「です・ます」調
- 特徴：絵文字を適度に使う（多用しない）

この設定で、ユーザーの質問に答えてください。
```

---

## 4. 変数を使ったプロンプト

### 変数とは

**変数**は、ユーザーの入力や他のノードの結果を受け取る「箱」のようなものです。
この箱に毎回違う言葉を入れることで、同じプロンプトでも異なる回答を作ることができます。

```
変数なし：「天気について教えて」
→ 毎回「天気」についてしか答えない

変数あり：「{{topic}}について教えて」
→ 箱(topic)に「料理」を入れると...「料理について教えて」になる
→ 箱(topic)に「歴史」を入れると...「歴史について教えて」になる
```

### 開始ブロック（開始ノード）とは

**開始ブロック**は、ワークフローの入り口となる特別なノードです。ここで定義した変数が、ユーザーからの入力を受け取ります。

#### 開始ブロックの役割

```
[ユーザー] → 入力 → [開始ブロック] → 変数として保存 → [LLMノードなどで使用]
```

**主な機能：**
- ユーザーからの入力を受け取る
- 入力の種類（テキスト、ファイル、数値など）を定義
- 必須/任意の設定
- デフォルト値の設定

#### 開始ブロックで設定できる項目

| 項目 | 説明 | 例 |
|------|------|-----|
| **フィールド名** | 変数の名前（英数字とアンダースコア） | `user_question`, `topic`, `input_text` |
| **フィールドタイプ** | データの種類 | テキスト、段落、数値、ファイルなど |
| **必須** | 入力が必須かどうか | はい/いいえ |
| **説明** | ユーザーへの入力ガイド | 「質問を入力してください」 |
| **デフォルト値** | 初期値（オプション） | 「こんにちは」 |

#### フィールドタイプの種類

1. **テキスト（Text）**
   - 短い1行の入力
   - 例：名前、タイトル、キーワード

2. **段落（Paragraph）**
   - 複数行の長文入力
   - 例：質問文、レビュー、記事

3. **数値（Number）**
   - 数字のみの入力
   - 例：年齢、金額、文字数

4. **ファイル（File）**
   - ファイルのアップロード
   - 例：画像、PDF、CSV

5. **選択（Select）**
   - プルダウンからの選択
   - 例：「簡単/普通/詳しく」「日本語/英語」

#### 開始ブロックの変数と会話変数の違い

Difyには2種類の変数があります。それぞれの特徴と使い分けを理解しましょう。

##### 1. 開始ブロックの変数（入力変数）

**特徴：**
- ワークフローが**実行されるたびに**ユーザーから入力を受け取る
- 1回のワークフロー実行中のみ有効
- ワークフローが終わると値は消える

**用途例：**
```
質問応答ボット
→ 毎回異なる質問を受け付ける
→ 質問ごとに新しい値が入力される
```

**ライフサイクル：**
```
[ワークフロー開始] → 変数に値を設定 → 処理実行 → [ワークフロー終了] → 値が消える
```

##### 2. 会話変数（Conversation Variables）

**特徴：**
- **複数回の会話を通じて**値を保持し続ける
- チャットボットアプリで使用
- ユーザーとの会話履歴全体で共有される

**用途例：**
```
カスタマーサポートチャット
→ 1回目：顧客名「山田太郎」を記憶
→ 2回目：「山田様、前回のご注文について...」と前回の情報を参照
→ 3回目：過去の会話内容を踏まえた対応
```

**ライフサイクル：**
```
[会話開始] → 変数に値を保存 → [会話継続] → 値を参照・更新 → [会話終了] → 値が保存される
```

##### 比較表

| 項目 | 開始ブロックの変数 | 会話変数 |
|------|-------------------|----------|
| **スコープ** | 1回のワークフロー実行 | 会話全体（複数回のやり取り） |
| **設定場所** | 開始ノード | ワークフロー設定 |
| **値の保持** | ワークフロー終了で消える | 会話が続く限り保持 |
| **使用場面** | ワークフロー型アプリ | チャットボット型アプリ |
| **更新方法** | 毎回ユーザーが入力 | ワークフロー内で更新可能 |
| **例** | `{{question}}`, `{{topic}}` | `{{customer_name}}`, `{{order_id}}` |

##### 使い分けの例

**例1: 質問応答ボット（開始ブロックの変数を使用）**
```
ユーザー入力: 「プロンプトとは？」
→ 開始変数 question = "プロンプトとは？"
→ LLMが回答
→ ワークフロー終了（変数消える）

次の質問: 「温度パラメータとは？」
→ 新しい開始変数 question = "温度パラメータとは？"
→ 前回の質問は関係なし
```

**例2: カスタマーサポート（会話変数を使用）**
```
1回目の会話:
ユーザー: 「注文したいです」
→ 会話変数 customer_name = "山田太郎" を保存
→ 会話変数 order_status = "相談中" を保存

2回目の会話（同じセッション内）:
ユーザー: 「配送先を変更したい」
→ 会話変数から customer_name を参照 → "山田様"
→ 会話変数から order_status を参照 → "相談中"
→ 前回の文脈を踏まえた対応が可能
```

##### 重要なポイント：アプリ種類の使い分け

| アプリの種類 | 特徴 | 向いていること |
|------------|------|----------------|
| **ワークフロー** | 1回完結型 | 記事生成、翻訳、分析、データ処理 |
| **チャットボット** | 会話継続型 | 質問応答、相談相手、カスタマーサポート |

※今回の演習では、仕組みを理解しやすい「ワークフロー」を使いますが、実際のチャットボット作りでは「チャットボット（Chatflow）」モードを使うのが一般的です。

### 入力変数の作成

#### ステップ1: 開始ノードで変数を定義

1. **開始ノード**をクリック
2. 「入力フィールドを追加」をクリック
3. 以下を設定：
   - **フィールド名**：`user_question`
   - **フィールドタイプ**：テキスト
   - **必須**：はい
   - **説明**：ユーザーの質問

#### ステップ2: プロンプトで変数を使用

LLMノードのプロンプト欄に以下を入力：

```
あなたは何でも答えられるAIアシスタントです。

ユーザーからの質問：{{user_question}}

上記の質問に、分かりやすく丁寧に答えてください。
```

**ポイント：** `{{変数名}}` で変数を参照します

### 複数の変数を使う例

**入力変数：**
- `topic`：話題（例：料理、旅行、スポーツ）
- `detail_level`：詳しさ（例：簡単、普通、詳しく）
- `target_audience`：対象者（例：小学生、大人）

**プロンプト：**
```
対象者：{{target_audience}}

{{topic}}について、{{detail_level}}説明してください。

説明のポイント：
- 対象者に合わせた言葉遣い
- 具体例を含める
- 分かりやすい構成
```

### 条件分岐ノードを使った処理の切り替え

変数の値によって、異なる処理を実行したい場合は**条件分岐ノード（IF/ELSEノード）**を使います。

**条件分岐ノードでできること：**
- 変数の値を判定して、処理フローを分岐
- 異なるLLMノードや処理を実行
- 複雑なビジネスロジックの実装

**例：対象者によって説明方法を変える**

**ワークフロー構成：**
```
[開始ノード]
  ↓
  入力変数：detail_level（選択：「簡単」「普通」「専門的」）
  入力変数：topic（テキスト）
  ↓
[条件分岐ノード]
  ├─ detail_level = "簡単" → [LLMノード：小学生向け説明]
  ├─ detail_level = "普通" → [LLMノード：一般向け説明]
  └─ detail_level = "専門的" → [LLMノード：専門家向け説明]
  ↓
[終了ノード]
```

**条件分岐ノードの設定：**
1. 開始ノードの次に「IF/ELSE」ノードを追加
2. 条件を設定：
   - **IF条件1**：`{{detail_level}}` が `簡単` に等しい
   - **ELIF条件2**：`{{detail_level}}` が `普通` に等しい
   - **ELSE**：上記以外（専門的）

**各分岐先のLLMノードのプロンプト例：**

**LLMノード1（簡単）：**
```
あなたは小学生にも分かりやすく教える先生です。

トピック：{{topic}}

上記のトピックについて、小学生にも分かるように説明してください。
- ひらがなを多く使う
- 難しい言葉は使わない
- 身近な例えを使う
```

**LLMノード2（普通）：**
```
あなたは一般向けの解説者です。

トピック：{{topic}}

上記のトピックについて、一般的な大人向けに説明してください。
- 標準的な言葉遣い
- 適度に専門用語を使用
- 分かりやすい構成
```

**LLMノード3（専門的）：**
```
あなたは専門家向けの技術解説者です。

トピック：{{topic}}

上記のトピックについて、専門家向けに詳細に説明してください。
- 専門用語を積極的に使用
- 技術的な詳細を含める
- 高度な内容
```

**この方法のメリット：**
- ✅ 各レベルに特化したプロンプトを作成できる
- ✅ プロンプトが読みやすく、メンテナンスしやすい
- ✅ 分岐ごとに異なるモデルや設定を使える
- ✅ ビジュアルでワークフローの流れが分かりやすい

**注意：** 構造化出力と条件分岐を組み合わせた実践的な演習は、[演習8](#演習8-問い合わせ自動振り分けシステム構造化出力--条件分岐ノード)と[演習9](#演習9-商品レビュー自動返信システム構造化出力--複数条件分岐)を参照してください。

### ノード間での変数の受け渡し

```
[開始ノード]
  ↓ user_question
[LLMノード1] ← 質問に回答
  ↓ output（生成された回答）
[LLMノード2] ← {{LLMノード1.output}}を要約
  ↓
[終了ノード]
```

**LLMノード2のプロンプト例：**
```
以下の文章を3行で要約してください：

{{LLMノード1.output}}
```

---

## 5. 実践：AIアシスタントを作る

### 演習1: シンプルな質問応答ボット

**目標：** ユーザーの質問に答えるボットを作成

#### 手順

1. **ワークフロー作成**
   - 名前：「質問応答ボット」

2. **開始ノードの設定**
   - 入力変数を追加
     - フィールド名：`question`
     - タイプ：テキスト
     - 必須：はい

3. **LLMノードの追加と設定**
   - モデル：gemini-2.5-flash
   - Temperature：0.7
   - Max Tokens：1024

   **プロンプト：**
   ```
   あなたは親切で知識豊富なAIアシスタントです。
   ユーザーの質問に対して、正確で分かりやすい回答を提供してください。

   質問：{{question}}

   回答：
   ```

4. **終了ノードの設定**
   - 出力変数：`{{text}}`

5. **テスト実行**
   - 質問例：「プロンプトエンジニアリングとは何ですか？」

### 演習2: レビュー感情分析ツール

**目標：** 商品レビューをポジティブ/ネガティブ/ニュートラルに分類

#### 入力変数
- `review_text`：レビュー文

#### プロンプト

```
あなたは商品レビューの分析専門家です。

以下の例を参考に、レビューを分類してください。

【例1】
レビュー：「素晴らしい商品です。買って良かった！」
分類：ポジティブ
理由：満足度の高い表現が使われている

【例2】
レビュー：「思っていたものと違いました。残念です。」
分類：ネガティブ
理由：失望を表す表現が使われている

【例3】
レビュー：「普通の商品です。特に良くも悪くもない。」
分類：ニュートラル
理由：中立的な表現

【分類対象】
レビュー：{{review_text}}

以下の形式で回答してください：
分類：[ポジティブ/ネガティブ/ニュートラル]
理由：[簡潔に説明]
```

#### テスト用レビュー

```
「配送が早く、商品も期待通りでした。また利用したいです。」
→ ポジティブ

「値段の割には品質が良くないと感じました。」
→ ネガティブ

「可もなく不可もなく、普通の商品だと思います。」
→ ニュートラル
```

### 演習3: ブログ記事生成アシスタント

**目標：** テーマを入力すると、構成まで考えてブログ記事を生成

#### 入力変数
- `article_topic`：記事のテーマ
- `target_length`：文字数（500/1000/2000）
- `tone`：トーン（カジュアル/フォーマル）

#### ワークフロー構成

```
[開始] → [LLMノード1：構成案] → [条件分岐：トーン判定]
                                  ├─ カジュアル → [LLMノード2a：カジュアル本文]
                                  └─ フォーマル → [LLMノード2b：フォーマル本文]
                                  ↓
                                [終了]
```

#### LLMノード1のプロンプト（構成案作成）

```
あなたはプロのライターです。

以下の条件でブログ記事の構成案を作成してください：

テーマ：{{#start.article_topic#}}
文字数：約{{#start.target_length#}}文字
トーン：{{#start.tone#}}

以下の形式で構成案を出力してください：

タイトル：
導入：（どのような書き出しにするか）
本文の構成：
1. 見出し1
   - 含める内容
2. 見出し2
   - 含める内容
3. 見出し3
   - 含める内容
まとめ：（どのように締めくくるか）
```

#### 条件分岐ノード：トーン判定

- **条件式：** `{{#start.tone#}} == "カジュアル"`
- **IF（真）：** LLMノード2a（カジュアル本文生成）へ
- **ELSE（偽）：** LLMノード2b（フォーマル本文生成）へ

#### LLMノード2aのプロンプト（カジュアル本文生成）

```
以下の構成案に基づいて、カジュアルで親しみやすいブログ記事を書いてください。

【構成案】
{{#llm1.text#}}

【執筆ルール】
- 目標文字数：{{#start.target_length#}}文字
- 親しみやすい口調（です・ます調）
- 読者に語りかけるような文体
- 適度に体験談や具体例を混ぜる
- 読みやすい段落構成

それでは、記事本文をお願いします：
```

#### LLMノード2bのプロンプト（フォーマル本文生成）

```
以下の構成案に基づいて、フォーマルで専門的なブログ記事を書いてください。

【構成案】
{{#llm1.text#}}

【執筆ルール】
- 目標文字数：{{#start.target_length#}}文字
- フォーマルな文体
- 客観的な情報とデータを中心に
- 論理的で構造化された表現
- 読みやすい段落構成

それでは、記事本文をお願いします：
```

#### テスト実行

**入力例：**
- article_topic：「在宅勤務を快適にする方法」
- target_length：1000
- tone：カジュアル

### 演習4: カスタマーサポートボット

**目標：** 丁寧な言葉遣いで顧客対応するボット

#### 入力変数
- `customer_inquiry`：顧客の問い合わせ
- `product_category`：製品カテゴリ（電化製品/衣類/食品）

#### プロンプト

```
あなたは当社のカスタマーサポート担当者です。

【対応方針】
- 常に丁寧で親切な対応
- 顧客の不安を取り除く
- 具体的で分かりやすい説明
- 必要に応じて次のステップを案内

【製品カテゴリ】
{{product_category}}

【お客様からのお問い合わせ】
{{customer_inquiry}}

以下の形式で回答してください：

■ お問い合わせ内容の確認
（お客様の質問を言い換えて確認）

■ 回答
（分かりやすく丁寧に説明）

■ 追加のご案内
（必要に応じて、関連情報や次のステップを案内）

■ 締めの言葉
（感謝の言葉や、何かあればいつでもご連絡くださいという旨）
```

---

## 6. 構造化出力（Structured Output）

### 構造化出力とは

**構造化出力**は、AIの出力を決まった形式（JSON形式）で受け取る機能です。プログラムで処理しやすいデータを作りたい場合に使います。

#### 普通のテキスト出力 vs 構造化出力

**普通のテキスト出力：**
```
ユーザー名: 山田太郎
年齢: 30
趣味: 読書、旅行
```
→ 人間には読みやすいが、プログラムで処理しにくい

**構造化出力（JSON）：**
```json
{
  "username": "山田太郎",
  "age": 30,
  "interests": ["読書", "旅行"]
}
```
→ プログラムで簡単に処理できる

### いつ使うのか

| 使用場面 | 説明 |
|---------|------|
| **データベース保存** | ユーザー情報、商品情報などを保存 |
| **API連携** | 他のシステムにデータを渡す |
| **ワークフロー連携** | 次のノードで特定の値だけ使いたい |
| **複数の値を抽出** | 文章から名前、日付、金額などを抽出 |

### JSON Schemaとは

**JSON Schema**は、JSONデータの「型紙」のようなものです。どんなデータがどんな形で出てくるかを定義します。

#### JSON Schemaの基本構造

```json
{
  "type": "object",
  "properties": {
    "フィールド名1": {
      "type": "データ型",
      "description": "説明"
    }
  },
  "required": ["必須フィールド名"]
}
```

#### 主なデータ型

| データ型 | 説明 | 例 |
|---------|------|-----|
| **string** | 文字列 | `"こんにちは"`, `"2024-01-01"` |
| **number** | 数値 | `30`, `3.14` |
| **boolean** | 真偽値 | `true`, `false` |
| **array** | 配列（リスト） | `["りんご", "バナナ"]` |
| **object** | オブジェクト（入れ子） | `{"name": "太郎"}` |

### 構造化出力の設定方法

#### ステップ1: 対応モデルを選択

構造化出力は、すべてのモデルで使えるわけではありません。以下のような対応モデルを選びましょう：

**主な対応モデル：**
- OpenAI GPT-4o / GPT-4o-mini
- Claude 4.5 Sonnet / Claude 4.5 Opus
- Google Gemini 2.5 Flash / Gemini 2.5 Pro

**注意：** 小型モデル（70B以下やGPT-3.5レベル）では、JSON Schema解析に失敗することがあります。

#### ステップ2: Response Formatを設定

1. LLMノードの設定パネルを開く
2. 「応答形式（Response Format）」を**JSON Schema**に変更
3. JSON Schemaエディターが表示される

#### ステップ3: JSON Schemaを定義

エディター内に、期待する出力の構造を定義します。

**例1：ユーザー情報の抽出**
```json
{
  "type": "object",
  "properties": {
    "username": {
      "type": "string",
      "description": "ユーザーの名前"
    },
    "age": {
      "type": "number",
      "description": "ユーザーの年齢"
    },
    "interests": {
      "type": "array",
      "description": "興味・趣味のリスト",
      "items": {
        "type": "string"
      }
    }
  },
  "required": ["username", "age", "interests"]
}
```

#### ステップ4: プロンプトで指示

プロンプト内で、どのようなデータを抽出してほしいかを明確に指示します。

```
以下の文章から、ユーザー情報を抽出してJSON形式で出力してください。

文章：{{user_text}}

抽出する情報：
- username: ユーザーの名前
- age: 年齢（数値）
- interests: 趣味や興味（配列）
```

チャット入力欄に以下を記述
```
はじめまして。
私の名前は 高橋 恒一（たかはし こういち）、32歳です。現在は都内で出版社の編集者として働いています。

趣味は 街歩きと古書店巡り です。休日には特に目的を決めず、気になる路地や小さな書店に立ち寄りながら、昔のエッセイや絶版本を探すのが楽しみです。本を通じて、過去の人の考え方や時代の空気に触れられる瞬間に魅力を感じています。

最近は、見つけた本の内容を簡単にノートにまとめることも習慣になりました。仕事とは少し違う形で言葉と向き合える、大切な時間です。

まだ知らない場所や本に出会えることを楽しみにしながら、日々を過ごしています。どうぞよろしくお願いします。
```

出力例
```
{"username":"高橋 恒一","age":32,"interests":["街歩き","古書店巡り"]}
```

### 実例：さまざまなJSON Schema

#### 例1：商品レビュー分析

**目的：** レビューの感情と評価点を抽出

**JSON Schema：**
```json
{
  "type": "object",
  "properties": {
    "sentiment": {
      "type": "string",
      "description": "感情分類",
      "enum": ["ポジティブ", "ネガティブ", "ニュートラル"]
    },
    "rating": {
      "type": "number",
      "description": "評価（1〜5）"
    },
    "key_points": {
      "type": "array",
      "description": "レビューの要点",
      "items": {
        "type": "string"
      }
    }
  },
  "required": ["sentiment", "rating", "key_points"]
}
```

**プロンプト：**
```
以下の商品レビューを分析してください：

レビュー：{{review_text}}

以下の項目を抽出してJSON形式で出力してください：
- sentiment: ポジティブ、ネガティブ、ニュートラルのいずれか
- rating: 1〜5の評価点
- key_points: レビューで言及されている重要なポイント（配列）
```

#### 例2：問い合わせ内容の分類

**目的：** カスタマーサポートの問い合わせを自動分類

**JSON Schema：**
```json
{
  "type": "object",
  "properties": {
    "category": {
      "type": "string",
      "description": "問い合わせカテゴリ",
      "enum": ["配送", "返品・交換", "商品情報", "支払い", "その他"]
    },
    "urgency": {
      "type": "string",
      "description": "緊急度",
      "enum": ["高", "中", "低"]
    },
    "customer_name": {
      "type": "string",
      "description": "顧客名"
    },
    "summary": {
      "type": "string",
      "description": "問い合わせ内容の要約"
    }
  },
  "required": ["category", "urgency", "summary"]
}
```

#### 例3：数学的推論のステップ記録

**目的：** 計算の過程を段階的に記録

**JSON Schema：**
```json
{
  "type": "object",
  "properties": {
    "steps": {
      "type": "array",
      "description": "推論ステップの配列",
      "items": {
        "type": "object",
        "properties": {
          "explanation": {
            "type": "string",
            "description": "このステップの説明"
          },
          "output": {
            "type": "string",
            "description": "このステップの結果"
          }
        },
        "required": ["explanation", "output"]
      }
    },
    "final_answer": {
      "type": "string",
      "description": "最終的な答え"
    }
  },
  "required": ["steps", "final_answer"]
}
```

**プロンプト：**
```
以下の数学問題を解き、段階的な推論過程をJSON形式で出力してください：

問題：{{math_problem}}

各ステップで以下を記録してください：
- explanation: そのステップで何をしているか
- output: そのステップの結果
- final_answer: 最終的な答え
```

#### 例4：記事情報の抽出

**JSON Schema：**
```json
{
  "type": "object",
  "properties": {
    "title": {
      "type": "string",
      "description": "記事タイトル"
    },
    "author": {
      "type": "string",
      "description": "著者名"
    },
    "publish_date": {
      "type": "string",
      "description": "公開日（YYYY-MM-DD形式）"
    },
    "tags": {
      "type": "array",
      "description": "タグ（カテゴリ）",
      "items": {
        "type": "string"
      }
    },
    "summary": {
      "type": "string",
      "description": "記事の要約（100文字以内）"
    }
  },
  "required": ["title", "summary"]
}
```

### 構造化出力の演習

#### 演習5: 名刺情報抽出ツール

**目標：** 名刺の文章から、構造化された連絡先情報を抽出

**手順：**

1. **ワークフロー作成**
   - 名前：「名刺情報抽出」

2. **開始ノードの設定**
   - 入力変数：`business_card_text`（段落）
   - 説明：「名刺に書かれている情報を入力してください」

3. **LLMノードの設定**
   - モデル：gemini-2.5 flash
   - Response Format：**JSON Schema**

   **JSON Schema：**
   ```json
   {
     "type": "object",
     "properties": {
       "name": {
         "type": "string",
         "description": "氏名"
       },
       "company": {
         "type": "string",
         "description": "会社名"
       },
       "position": {
         "type": "string",
         "description": "役職"
       },
       "email": {
         "type": "string",
         "description": "メールアドレス"
       },
       "phone": {
         "type": "string",
         "description": "電話番号"
       },
       "address": {
         "type": "string",
         "description": "住所"
       }
     },
     "required": ["name", "company"]
   }
   ```

   **プロンプト：**
   ```
   以下の名刺情報から、構造化されたデータを抽出してください。

   名刺の内容：
   {{business_card_text}}

   以下のフィールドを抽出してJSON形式で返してください：
   - name: 氏名
   - company: 会社名
   - position: 役職
   - email: メールアドレス
   - phone: 電話番号
   - address: 住所

   情報が記載されていない項目は、nullとしてください。
   ```

4. **テスト入力：**
   ```
   山田太郎
   株式会社テックソリューションズ
   営業部長
   📧 yamada@techsol.co.jp
   📱 090-1234-5678
   〒100-0001 東京都千代田区千代田1-1-1
   ```

   **期待される出力：**
   ```json
   {
     "name": "山田太郎",
     "company": "株式会社テックソリューションズ",
     "position": "営業部長",
     "email": "yamada@techsol.co.jp",
     "phone": "090-1234-5678",
     "address": "〒100-0001 東京都千代田区千代田1-1-1"
   }
   ```

#### 演習6: ニュース記事の要点整理

**目標：** ニュース記事から重要情報を構造化して抽出

**JSON Schema：**
```json
{
  "type": "object",
  "properties": {
    "headline": {
      "type": "string",
      "description": "見出し（20文字以内）"
    },
    "what": {
      "type": "string",
      "description": "何が起きたか"
    },
    "who": {
      "type": "string",
      "description": "誰が関わっているか"
    },
    "when": {
      "type": "string",
      "description": "いつ"
    },
    "where": {
      "type": "string",
      "description": "どこで"
    },
    "impact": {
      "type": "string",
      "description": "影響・重要度"
    }
  },
  "required": ["headline", "what"]
}
```

**プロンプト：**
```
以下のニュース記事を分析し、5W1H形式で重要情報を抽出してください：

記事：
{{news_text}}

以下のフィールドをJSON形式で返してください：
- headline: 記事の見出し（20文字以内）
- what: 何が起きたか
- who: 誰が関わっているか
- when: いつのことか
- where: どこで起きたか
- impact: 社会的影響や重要度
```

**テスト入力例：**
```
東京都は本日、2025年4月から都内の公立学校全校にAI学習支援システムを導入すると発表した。
このシステムは、生徒一人ひとりの学習進度に合わせて最適な問題を提示する機能を持ち、
教員の負担軽減と個別最適化された学習環境の実現を目指す。
都教育委員会の田中委員長は「デジタル技術を活用した教育改革の第一歩」とコメントしている。
導入費用は約50億円で、全国初の取り組みとなる。
```

**期待される出力：**
```json
{
  "headline": "都立校にAI学習支援導入",
  "what": "公立学校全校にAI学習支援システムを導入",
  "who": "東京都・都教育委員会",
  "when": "2025年4月から",
  "where": "東京都内の公立学校",
  "impact": "教育のデジタル化推進、全国初の取り組み、導入費用約50億円"
}
```

#### 演習7: レシピ情報の構造化

**目標：** 料理レシピから材料と手順を抽出

**JSON Schema：**
```json
{
  "type": "object",
  "properties": {
    "dish_name": {
      "type": "string",
      "description": "料理名"
    },
    "servings": {
      "type": "number",
      "description": "何人分"
    },
    "cooking_time": {
      "type": "number",
      "description": "調理時間（分）"
    },
    "ingredients": {
      "type": "array",
      "description": "材料リスト",
      "items": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "材料名"
          },
          "amount": {
            "type": "string",
            "description": "分量"
          }
        },
        "required": ["name", "amount"]
      }
    },
    "steps": {
      "type": "array",
      "description": "調理手順",
      "items": {
        "type": "string"
      }
    }
  },
  "required": ["dish_name", "ingredients", "steps"]
}
```

**プロンプト：**
```
以下のレシピから、料理名、材料、手順を抽出してJSON形式で出力してください。

レシピ：
{{recipe_text}}

以下のフィールドをJSON形式で返してください：
- dish_name: 料理名
- servings: 何人分（数値）
- cooking_time: 調理時間（分、数値）
- ingredients: 材料リスト（配列、各要素は name と amount を持つオブジェクト）
- steps: 調理手順（文字列の配列）
```

**テスト入力例：**
```
【簡単トマトパスタ】

2人分、調理時間15分

■材料
・パスタ 200g
・トマト缶 1缶（400g）
・にんにく 2片
・オリーブオイル 大さじ2
・塩 小さじ1/2
・バジル 適量

■作り方
1. 大きめの鍋にたっぷりのお湯を沸かし、塩を加えてパスタを茹でる
2. フライパンにオリーブオイルとみじん切りにしたにんにくを入れ、弱火で香りが出るまで炒める
3. トマト缶を加え、中火で5分ほど煮詰める
4. 塩で味を調える
5. 茹で上がったパスタを加えて絡め、バジルをトッピングして完成
```

**期待される出力：**
```json
{
  "dish_name": "簡単トマトパスタ",
  "servings": 2,
  "cooking_time": 15,
  "ingredients": [
    {"name": "パスタ", "amount": "200g"},
    {"name": "トマト缶", "amount": "1缶（400g）"},
    {"name": "にんにく", "amount": "2片"},
    {"name": "オリーブオイル", "amount": "大さじ2"},
    {"name": "塩", "amount": "小さじ1/2"},
    {"name": "バジル", "amount": "適量"}
  ],
  "steps": [
    "大きめの鍋にたっぷりのお湯を沸かし、塩を加えてパスタを茹でる",
    "フライパンにオリーブオイルとみじん切りにしたにんにくを入れ、弱火で香りが出るまで炒める",
    "トマト缶を加え、中火で5分ほど煮詰める",
    "塩で味を調える",
    "茹で上がったパスタを加えて絡め、バジルをトッピングして完成"
  ]
}
```

#### 演習8: 問い合わせ自動振り分けシステム（構造化出力 + 条件分岐ノード）

**目標：** 問い合わせ内容を分析し、緊急度に応じて異なる担当部署に自動振り分け

このワークフローでは、LLMノードの構造化出力結果を条件分岐ノードで判定し、異なる処理フローに分岐させます。

**ワークフロー構成：**
```
[開始ノード]
  ↓
[LLMノード：問い合わせ分析]（構造化出力）
  ↓
[条件分岐ノード：緊急度判定]
  ├─ 緊急度「高」 → [LLMノード：緊急対応メッセージ生成]
  ├─ 緊急度「中」 → [LLMノード：標準対応メッセージ生成]
  └─ 緊急度「低」 → [LLMノード：自動応答メッセージ生成]
  ↓
[終了ノード]
```

**手順：**

**1. 開始ノードの設定**
- 入力変数：`inquiry_text`（段落） - 問い合わせ内容

**2. LLMノード1「問い合わせ分析」の設定**
- モデル：gemini-2.5-flash
- Response Format：**JSON Schema**

**JSON Schema：**
```json
{
  "type": "object",
  "properties": {
    "category": {
      "type": "string",
      "description": "問い合わせカテゴリ",
      "enum": ["システム障害", "返金・返品", "使い方", "一般問い合わせ", "クレーム"]
    },
    "urgency": {
      "type": "string",
      "description": "緊急度",
      "enum": ["高", "中", "低"]
    },
    "summary": {
      "type": "string",
      "description": "問い合わせ内容の要約"
    },
    "customer_emotion": {
      "type": "string",
      "description": "顧客の感情",
      "enum": ["怒り", "困惑", "中立", "満足"]
    }
  },
  "required": ["category", "urgency", "summary", "customer_emotion"]
}
```

**プロンプト：**
```
以下の問い合わせ内容を分析し、カテゴリと緊急度を判定してください。

【問い合わせ内容】
{{inquiry_text}}

【判定基準】
- 「動かない」「エラー」「障害」「使えない」→ カテゴリ：システム障害、緊急度：高
- 「返金」「返品」「キャンセル」→ カテゴリ：返金・返品、緊急度：中
- 「使い方」「方法」「設定」→ カテゴリ：使い方、緊急度：低
- 「クレーム」「苦情」「怒り」の表現 → カテゴリ：クレーム、緊急度：高
- その他 → カテゴリ：一般問い合わせ、緊急度：低

【顧客の感情】
- 強い不満や怒りの表現がある → 怒り
- 困っている様子 → 困惑
- 普通の問い合わせ → 中立
- お礼や満足の表現 → 満足

JSON形式で出力してください。
```

**3. 条件分岐ノードの追加**
1. LLMノード1の右側の「＋」をクリック
2. 「IF/ELSE」ノードを選択
3. 条件設定：
   - **IF条件1**：`{{LLMノード1.urgency}}` が `高` に等しい
   - **ELIF条件2**：`{{LLMノード1.urgency}}` が `中` に等しい
   - **ELSE**：上記以外（緊急度「低」）

**4. 各分岐先のLLMノード設定**

**LLMノード2「緊急対応メッセージ」（緊急度：高の場合）**
- Response Format：Text

**プロンプト：**
```
【緊急対応が必要な問い合わせ】
カテゴリ：{{LLMノード1.category}}
要約：{{LLMノード1.summary}}
顧客感情：{{LLMノード1.customer_emotion}}

上記の情報をもとに、以下の形式で緊急対応メッセージを作成してください：

■ 対応部署
専任サポートチーム

■ 対応期限
即時対応（15分以内に連絡）

■ 担当者へのメッセージ
（顧客の感情に配慮した、優先対応すべき理由を記載）

■ 顧客への返信テンプレート
（謝罪と即座の対応を約束する内容）
```

**LLMノード3「標準対応メッセージ」（緊急度：中の場合）**
- Response Format：Text

**プロンプト：**
```
【標準対応の問い合わせ】
カテゴリ：{{LLMノード1.category}}
要約：{{LLMノード1.summary}}
顧客感情：{{LLMノード1.customer_emotion}}

上記の情報をもとに、以下の形式で標準対応メッセージを作成してください：

■ 対応部署
一般サポートチーム

■ 対応期限
6時間以内

■ 担当者へのメッセージ
（対応時の注意点を記載）

■ 顧客への返信テンプレート
（丁寧な対応を約束する内容）
```

**LLMノード4「自動応答メッセージ」（緊急度：低の場合）**
- Response Format：Text

**プロンプト：**
```
【自動応答で対応可能な問い合わせ】
カテゴリ：{{LLMノード1.category}}
要約：{{LLMノード1.summary}}

上記の情報をもとに、以下の形式で自動応答メッセージを作成してください：

■ 対応方法
FAQページ案内 + 必要に応じてメール対応

■ 対応期限
24時間以内

■ 顧客への自動返信
（FAQへのリンクと、必要であれば担当者が後ほど連絡する旨を記載）
```

**5. テスト入力例**

**ケース1：緊急度「高」の場合**
```
システムにログインできません。
「エラーコード500」と表示されて、本日中に提出しないといけない
重要な書類が取り出せず、非常に困っています。
至急対応をお願いします！
```

**期待される動作：**
1. LLMノード1が以下を出力：
```json
{
  "category": "システム障害",
  "urgency": "高",
  "summary": "ログイン不可、エラー500で重要書類にアクセスできない",
  "customer_emotion": "困惑"
}
```
2. 条件分岐ノードが「緊急度：高」を検出
3. LLMノード2（緊急対応）が実行される

**ケース2：緊急度「中」の場合**
```
先週購入した商品ですが、サイズが合わなかったので
返品したいと思っています。
返品手続きの方法を教えていただけますか？
```

**期待される動作：**
1. LLMノード1が以下を出力：
```json
{
  "category": "返金・返品",
  "urgency": "中",
  "summary": "サイズ不適合による返品希望",
  "customer_emotion": "中立"
}
```
2. 条件分岐ノードが「緊急度：中」を検出
3. LLMノード3（標準対応）が実行される

**ケース3：緊急度「低」の場合**
```
アプリの通知設定を変更したいのですが、
設定画面の場所がわかりません。
手順を教えてください。
```

**期待される動作：**
1. LLMノード1が以下を出力：
```json
{
  "category": "使い方",
  "urgency": "低",
  "summary": "通知設定の変更方法に関する問い合わせ",
  "customer_emotion": "中立"
}
```
2. 条件分岐ノードがELSE（緊急度：低）に該当
3. LLMノード4（自動応答）が実行される

**この演習のポイント：**
- ✅ LLMノードの構造化出力（JSON Schema）を使用
- ✅ 条件分岐ノード（IF/ELSE）で出力結果を判定
- ✅ 緊急度に応じて3つの異なる処理フローに分岐
- ✅ 実務的な問い合わせ対応システムの実装
- ✅ `{{ノード名.フィールド名}}`による変数参照の実践

#### 演習9: 商品レビュー自動返信システム（構造化出力 + 複数条件分岐）

**目標：** レビューの感情分析結果に基づいて、適切な返信メッセージを自動生成

**ワークフロー構成：**
```
[開始ノード]
  ↓
[LLMノード：レビュー分析]（構造化出力）
  ↓
[条件分岐ノード1：評価点数で分岐]
  ├─ 評価5点 → [LLMノード：感謝メッセージ]
  ├─ 評価3-4点 → [LLMノード：改善提案メッセージ]
  └─ 評価1-2点 → [条件分岐ノード2：感情で分岐]
                   ├─ 怒り → [LLMノード：謝罪＋補償提案]
                   └─ その他 → [LLMノード：謝罪＋改善約束]
  ↓
[終了ノード]
```

**手順：**

**1. 開始ノードの設定**
- 入力変数：`review_text`（段落） - レビュー内容

**2. LLMノード1「レビュー分析」の設定**
- モデル：gemini-2.5-flash
- Response Format：**JSON Schema**

**JSON Schema：**
```json
{
  "type": "object",
  "properties": {
    "rating": {
      "type": "number",
      "description": "評価点数（1-5）"
    },
    "sentiment": {
      "type": "string",
      "description": "感情",
      "enum": ["非常に満足", "満足", "普通", "不満", "怒り"]
    },
    "key_points": {
      "type": "array",
      "description": "レビューで言及されている要点",
      "items": {
        "type": "string"
      }
    },
    "mentioned_issues": {
      "type": "array",
      "description": "指摘されている問題点（なければ空配列）",
      "items": {
        "type": "string"
      }
    }
  },
  "required": ["rating", "sentiment", "key_points", "mentioned_issues"]
}
```

**プロンプト：**
```
以下の商品レビューを分析し、評価点数、感情、要点、問題点を抽出してください。

レビュー：
{{review_text}}

以下の基準で分析してください：
- rating: 1〜5の評価点数を推定
- sentiment: 「非常に満足」「満足」「普通」「不満」「怒り」のいずれか
- key_points: レビューで言及されている重要なポイント（配列）
- mentioned_issues: 指摘されている問題点（なければ空配列）

JSON形式で出力してください。
```

**3. 条件分岐ノード1の設定**
- IF条件1：`{{LLMノード1.rating}}` が `5` に等しい
- ELIF条件2：`{{LLMノード1.rating}}` が `3` 以上かつ `4` 以下
- ELSE：上記以外（評価1-2点）

**4. 低評価時の条件分岐ノード2の設定**
- IF条件：`{{LLMノード1.sentiment}}` が `怒り` に等しい
- ELSE：その他の感情

**5. テスト入力例**

**ケース1：高評価（5点）の場合**
```
素晴らしい商品です！期待以上のクオリティで、デザインも機能性も完璧。
購入して本当に良かったです。友人にもぜひ勧めたいと思います。
配送も迅速で、梱包も丁寧でした。大満足です！
```

**期待される動作：**
1. LLMノード1が以下を出力：
```json
{
  "rating": 5,
  "sentiment": "非常に満足",
  "key_points": ["クオリティが高い", "デザインが良い", "機能性が良い", "配送が迅速", "梱包が丁寧"],
  "mentioned_issues": []
}
```
2. 条件分岐ノード1が「評価5点」を検出
3. LLMノード（感謝メッセージ）が実行される

**ケース2：中評価（3-4点）の場合**
```
商品自体は悪くないですが、思っていたよりも少し小さかったです。
機能は問題なく使えていますが、説明書がわかりにくかったのが残念。
価格相応かなという感じです。
```

**期待される動作：**
1. LLMノード1が以下を出力：
```json
{
  "rating": 3,
  "sentiment": "普通",
  "key_points": ["サイズが小さい", "機能は問題なし", "価格相応"],
  "mentioned_issues": ["サイズが予想より小さい", "説明書がわかりにくい"]
}
```
2. 条件分岐ノード1が「評価3-4点」を検出
3. LLMノード（改善提案メッセージ）が実行される

**ケース3：低評価＋怒り（1-2点）の場合**
```
最悪の買い物でした。届いた商品が破損していて使えません。
カスタマーサポートに連絡しても返信が遅く、対応も不誠実です。
二度とこのショップでは買いません。星1つもつけたくないレベルです。
```

**期待される動作：**
1. LLMノード1が以下を出力：
```json
{
  "rating": 1,
  "sentiment": "怒り",
  "key_points": ["商品が破損", "サポート対応が悪い"],
  "mentioned_issues": ["商品破損", "返信が遅い", "対応が不誠実"]
}
```
2. 条件分岐ノード1が「評価1-2点」を検出
3. 条件分岐ノード2が「怒り」を検出
4. LLMノード（謝罪＋補償提案）が実行される

**この演習のポイント：**
- ✅ ネストした条件分岐（条件分岐の中に条件分岐）
- ✅ 数値フィールド（rating）を使った範囲判定
- ✅ 文字列フィールド（sentiment）を使った完全一致判定
- ✅ 複雑なビジネスロジックの実装

### 構造化出力の注意点とトラブルシューティング

#### よくあるエラーと対処法

##### エラー1: `Failed to parse structured output`

**原因：**
- モデルがJSON Schema非対応
- モデルの能力不足（小型モデル）
- Schemaが複雑すぎる

**対処法：**
1. より高性能なモデル（GPT-4o、Claude 4.5 Sonnet等）に変更
2. JSON Schemaをシンプルにする
3. プロンプトでJSON出力を明確に指示する

##### エラー2: 一部のフィールドが欠落

**原因：**
- `required`に指定されていない
- プロンプトで指示が不明確

**対処法：**
1. 必須フィールドは`required`配列に追加
2. プロンプトで各フィールドの意味を明確に説明

##### エラー3: 期待した型と異なる値が返る

**原因：**
- プロンプトとSchemaの説明が不一致
- AIの解釈違い

**対処法：**
1. `description`フィールドで詳しく説明
2. `enum`で選択肢を限定
3. プロンプトで具体例を示す

#### ベストプラクティス

✅ **Do（推奨）**
- 必須フィールドは必ず`required`に指定
- 各フィールドに`description`を記載
- 選択肢が限られる場合は`enum`を使用
- プロンプトでJSON Schemaの内容を説明

❌ **Don't（非推奨）**
- 複雑すぎるネスト構造（3階層以上）
- あいまいなフィールド名（`data`, `info`など）
- 説明のないフィールド
- 対応していないモデルで使用

### まとめ：構造化出力

✅ **学んだこと**
- JSON形式でデータを受け取る方法
- JSON Schemaの書き方
- 様々なユースケース（名刺、レビュー、ニュースなど）
- トラブルシューティング

✅ **使いどころ**
- データベース保存
- 他システムとの連携
- ワークフロー内での値の受け渡し
- 複数の情報を一度に抽出

---

## よくある質問（FAQ）

### Q1: プロンプトが長すぎると問題ありますか？

**A:** 長すぎるプロンプトは以下の問題があります：
- コストが高くなる
- 処理が遅くなる
- AIが重要な指示を見落とすことがある

**推奨：** 必要な情報に絞り、簡潔に書く

### Q2: Temperatureは何に設定すればいいですか？

**A:** タスクによって変えましょう：

| タスク | 推奨値 |
|--------|--------|
| 事実確認、計算 | 0.0 - 0.3 |
| 一般的なQ&A | 0.5 - 0.7 |
| 創作、アイデア出し | 0.8 - 1.0 |

### Q3: AIの回答が期待と違う場合は？

**A:** 以下を試してください：
1. プロンプトをより具体的にする
2. 例（Few-shot）を追加する
3. 出力形式を明示する
4. ステップバイステップで指示する

### Q4: 変数名に使える文字は？

**A:** 以下のルールがあります：
- 英数字とアンダースコア `_` のみ
- 数字から始めない
- スペースは使えない

**良い例：** `user_question`, `topic1`, `review_text`
**悪い例：** `ユーザー質問`, `1topic`, `review text`

### Q5: 構造化出力とテキスト出力はどう使い分けるべきですか？

**A:** 用途によって使い分けましょう：

| 用途 | 推奨形式 |
|------|---------|
| 人が読むための回答 | テキスト |
| データベースに保存 | 構造化出力（JSON） |
| 次のノードで特定の値を使う | 構造化出力（JSON） |
| 複数の情報を同時に抽出 | 構造化出力（JSON） |
| 自由な形式の文章生成 | テキスト |

### Q6: JSON Schemaで配列の中にオブジェクトを入れることはできますか？

**A:** できます。以下のように`items`の中に`type: "object"`を指定します：

```json
{
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "name": {"type": "string"},
      "value": {"type": "number"}
    }
  }
}
```

### Q7: 構造化出力が失敗する場合はどうすればいいですか？

**A:** 以下の順で確認・対処してください：
1. モデルがJSON Schema対応か確認（GPT-4o、Claude 4.5 Sonnet等を使用）
2. JSON Schemaをシンプルにする（ネストを浅くする）
3. `required`フィールドを確認
4. プロンプトでJSON形式での出力を明確に指示
5. それでもダメなら、Response Formatを「JSON」（Schema なし）に変更してプロンプトで形式を指定

---

## まとめ

### この回で学んだこと

✅ **LLMノードの基本**
- ストリーミングとブロッキングの違い
- モデルの選び方
- Temperatureなどのパラメータ設定

✅ **プロンプトの書き方**
- 役割、タスク、制約条件、出力形式の指定
- Few-shot（例示）の活用
- ステップバイステップの指示

✅ **変数の使い方**
- `{{変数名}}` で動的なプロンプト作成
- 複数の変数を組み合わせる
- ノード間で結果を受け渡す

✅ **実践的なアプリケーション**
- 質問応答ボット
- 感情分析ツール
- ブログ記事生成
- カスタマーサポート

✅ **構造化出力（JSON Schema）**
- JSON形式でのデータ受け取り
- JSON Schemaの定義方法
- 実践的なユースケース（名刺情報抽出、レビュー分析など）
- エラー対処とベストプラクティス

### 次のステップ

次回は、さらに高度な機能を学びます：

- **第3回：ナレッジベースとRAG**
  - 独自のドキュメントを使った回答生成
  - PDFやWebサイトの情報を活用
  - より正確で信頼性の高いAIアプリ

### 練習課題

以下のアプリケーションを自分で作ってみましょう：

1. **翻訳アシスタント**
   - 入力：日本語の文章、翻訳先言語
   - 出力：翻訳結果

2. **文章添削ツール**
   - 入力：添削してほしい文章
   - 出力：改善案と理由

3. **キャッチコピー生成**
   - 入力：商品名、特徴
   - 出力：3つのキャッチコピー案

4. **求人情報の構造化抽出（構造化出力を使用）**
   - 入力：求人票のテキスト
   - 出力：職種、給与、勤務地、必要スキルなどをJSON形式で抽出

5. **会議議事録の要約（構造化出力を使用）**
   - 入力：会議の内容
   - 出力：決定事項、アクションアイテム、参加者などをJSON形式で整理

### 参考リンク

- [Dify公式ドキュメント](https://docs.dify.ai/)
- [プロンプトエンジニアリングガイド](https://www.promptingguide.ai/jp)

---

**お疲れ様でした！** 分からないことがあれば、コミュニティやサポートに質問してみましょう。
